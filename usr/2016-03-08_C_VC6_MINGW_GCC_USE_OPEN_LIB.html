<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<head>
<title>C语言编译使用一些开源库的经验</title>
</head>
<body>

<xmp theme="cerulean" style="display:none;">

本文更新时间: `2016-03-08`

- 本文的**目的**: 介绍使用命令行来编译一些开源库，将其整合到主函数中

### 缘起
- 以前学习C语言的时候，最大的问题就是不知道该怎么调用第三方的库

- 这几周周末去图书馆看计算机方面的书，看到这么一本书 编码：隐匿在计算机软硬件背后的语言
- 它介绍了从继电器开始组装一台'计算机'的过程，让我恍然大悟，尼玛以前大学学的那些鬼课程终于知道为什么要学了，尽管细节忘光了，但终于不再一头雾水，可以说'顿悟'了，汗

- 之后再看C语言，竟然不再觉得忒困难了，尼玛，用二进制来编写才叫难好么

- 然后去研究VC6的编译，终于把几个常用的开源库给搞定，能让一些简单的Demo跑起来了，撒花


### 静态库和动态库
- 静态库:就是把第三方库的代码与自己代码编译到一起，形成可执行程序

- 动态库:第三方库的代码编译成特殊的库，主程序直接调用即可，便于模块化

### 从文件识别库类型
- 从文件识别静态库: windows下的 .lib文件(也有可能是.dll依赖的.lib)，linux下的 .a文件(也有可能是win平台下的mingw生成的库)
- 从文件识别动态库: windows下的 .dll文件，linux下的 .so文件

## windows下VC6命令行编译需要的文件

### 动态库
- xxx.dll : 动态链接库文件，当发布程序的时候，只要带上它和主程序即可

- xxx.lib : 可由动态链接库文件生成的库文件，可以看作是dll与C代码之间的桥梁，反正需要它，静动态库都需要它，相对来说静态库比较大，因为将库都包含在里面了，静态库因为有dll了，lib相对小很多

- xxx.h   : 该库的头文件，从源码里面找，一般在include文件夹下
- test.c  : 自己写的主文件


### 静态库
- xxx.lib : 静态库，包含已编译好的第三方库，等待链接

- xxx.h   : 该库的头文件，从源码里面找，一般在include文件夹下
- test.c  : 自己写的主文件


### 用法(VC6 动态库，静态库)
- test.c里面添加: #include "xxx.h"
- test.c里面添加: #pragma comment(lib, "xxx.lib")
- 然后在test.c里面使用即可

### 从动态库生成lib文件
- 动机: 有时候只有.dll文件和.h文件，或者.lib的版本不适合，需要重新生成

- 原理: xxx.dll 导出 xxx.def，xxx.def生成xxx.lib
- XXX.dll 导出 XXX.DEF
  - dumpbin.exe /exports xxx.dll > xxx.def
  - 修改上面的def文件，首行EXPORTS，后面每行一个导出函数名
- XXX.DEF 生成 XXX.LIB
  - lib.exe /MACHINE:IX86 /DEF:xxx.def /out:xxx.lib
- xxx.lib + xxx.h 就可以在工程中使用了DLL了


### 其他
- 现在可以使用非VC编译器将代码编译成dll，例如mingw下的gcc
- 将dll转成vc6下的lib文件，然后加上头文件，即可用在vc6的工程中
- 当然使用mingw来写代码也是可以的，如果木有GUI的话


</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>

<div class="AD" align="center"><script src="http://s14.cnzz.com/stat.php?id=3279032&web_id=3279032&online=1&show=line" language="JavaScript"></script></div>

</body>
</html>

